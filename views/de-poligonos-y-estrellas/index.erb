<!-- vim: set spelllang=es_mx: -->
<p>
Hace algun tiempo tuve la necesidad de desarrollar una aplicación en Java que dibujara polígonos regulares y estrellas de <span class="math inline"><em>n</em></span> lados y <span class="math inline"><em>n</em></span> picos respectivamente para una materia en la escuela. En un principio me fue difícil solucionar este problema pero al final encontré la manera. A continuación comento en que consiste la solución.
</p>
<p>
Es común que la mayoría de nosotros estemos familiarizados con el sistema de coordenadas rectangulares donde cada punto en el espacio se representa por dos valores de la forma <span class="math inline">(<em>x</em>,<em>y</em>)</span> donde <span class="math inline"><em>x</em>, <em>y</em> ∈ ℝ</span>, <span class="math inline"><em>x</em></span> corresponde al desplazamiento sobre la recta horizontal y <span class="math inline"><em>y</em></span> corresponde al desplazamiento vertical. Véase figura &lt;%= ref(“plano_cartesiano”); %&gt;.
</p>
<figure>
<img src="/de-poligonos-y-estrellas/plano_cartesiano.png" alt="Plano cartesiano y coordenadas rectangulares" />
<figcaption aria-hidden="true">Plano cartesiano y coordenadas rectangulares</figcaption>
</figure>
<p>
Con este sistema de coordenadas es posible representar cualquier objeto geométrico, incluyendo nuestros polígonos, sin embargo existen otros sistemas de coordenadas que nos facilitan las cosas para esta tarea en especial, me refiero a las <a href="http://es.wikipedia.org/wiki/Coordenadas_polares" target="_blank">coordenadas polares.</a>:
</p>
<figure>
<img src="/de-poligonos-y-estrellas/coordenadas_polares.png" alt="Coordenadas polares" />
<figcaption aria-hidden="true">Coordenadas polares</figcaption>
</figure>
<p>
Como se aprecia en la imagen el sistema consiste en una serie de círculos concéntricos con radios de diferente longitud en el rango <span class="math inline">[0,∞]</span>. Cada punto en el espacio es representado por la dupla <span class="math inline">(<em>r</em>,<em>θ</em>)</span> donde <span class="math inline"><em>r</em></span> es el radio de un círculo y <span class="math inline"><em>θ</em></span> el ángulo a partir de la recta horizontal en sentido anti-horario. Dependiendo de la unidad en que se midan los ángulos <span class="math inline"><em>θ</em></span> puede tomar los valores <span class="math inline">[−<em>π</em>,<em>π</em>]</span> o <span class="math inline">[0,2<em>π</em>]</span> si la unidad es el radián, o bien <span class="math inline">[0,360<sup>∘</sup>]</span> si la unidad se mide en grados.
</p>
<p>
Una vez asimilados estos conceptos podemos formular la solución. Para un polígono de <span class="math inline"><em>N</em></span> lados y radio <span class="math inline"><em>r</em></span> (radio del círculo circunscrito al polígono) las coordenadas de las <span class="math inline"><em>N</em></span> esquinas son <span class="math inline">$(r, 1\frac{2\pi}{N}), (r, 2\frac{2\pi}{N}), \ldots , (r, N\frac{2\pi}{N})$</span>. Para el caso de la estrella de <span class="math inline"><em>N</em></span> picos se trabaja de manera similar: Se construye un polígono regular de <span class="math inline"><em>N</em></span> lados y para cada par de puntos se agrega un punto más a la mitad de estos dos con un radio menor a <span class="math inline"><em>r</em></span> y por último solo resta unir los puntos con líneas rectas.
</p>
<p>
Hablemos un poco a cerca de la implementación. El lenguaje que empleo aquí es Java pero esto puede fácilmente ser portado a cualquier otro lenguaje ya que la teoría es la misma. Veamos pues como esta conformada el área de dibujo en Java:
</p>
<figure>
<img src="/de-poligonos-y-estrellas/coordenadas_java.png" alt="Sistema de coordenadas en Java" />
<figcaption aria-hidden="true">Sistema de coordenadas en Java</figcaption>
</figure>
<p>
El eje <span class="math inline"><em>x</em></span> se comporta tal cual lo conocemos pero al parecer tenemos un pequeño inconveniente con el eje <span class="math inline"><em>y</em></span> que se comporta de forma inversa, cuando <span class="math inline"><em>y</em></span> aumenta el desplazamiento es hacia abajo. Es necesario aplicar una pequeña transformación al eje <span class="math inline"><em>y</em></span> para restaurar su comportamiento y de esta manera facilitarnos las cosas. La transformación que necesitamos es una reflexión:
</p>
<p>$ y’ = maxY - y$</p>
<p>
Donde <span class="math inline"><em>m</em><em>a</em><em>x</em><em>Y</em></span> es la altura del área de dibujo. Para obtener el valor original de <span class="math inline"><em>y</em></span> a a partir de <span class="math inline"><em>y</em>′</span> empleamos la siguiente operación:
</p>
<p>$ y = maxY - y’$</p>
<p>
Ya casi tenemos todo listo para empezar a codificar, solo falta ver como convertir las coordenadas polares a rectangulares, pequeño detalle. De la siguiente ilustración se puede observar que tenemos los datos necesarios para obtener las componentes rectangulares de un punto.
</p>
<figure>
<img src="/de-poligonos-y-estrellas/polar_a_rectangular.png" alt="Componentes de un punto" />
<figcaption aria-hidden="true">Componentes de un punto</figcaption>
</figure>
<p>
La componente horizontal es el cateto adyacente y por tanto <span class="math inline"><em>x</em> = <em>r</em>cos (<em>θ</em>)</span>, el cateto opuesto es la componente vertical y de ahí que <span class="math inline"><em>y</em> = <em>r</em>sin (<em>θ</em>)</span>. Ahora sí, al código. Veamos como quedaría el método para calcular las coordenadas de un polígono:
</p>
<p>Embed: <code>compute-polygon.java</code></p>
<p>En las líneas 25 a 27 se hace una rotación a la figura con el fin de que el primer vértice del polígono coincida con el punto donde se encuentra el apuntador del ratón. Esta transformación en realidad no forma parte del algoritmo sino más bien por estética. Los métodos <code>int ly(int y)</code> y <code>int oy(int y)</code> se encargan de obtener <span class="math inline"><em>y</em>′</span> y <span class="math inline"><em>y</em></span> respectivamente.</p>
<pre lang="cpp" theme="slate" >
private int ly(int y) { return maxY - y; }
private int oy(int y) { return maxY - y; }
</pre>
<p>
Como pueden observer los métodos son idénticos, sin embargo el objetivo es distinto. Por claridad los emplearemos para sus respectivas funciones. El código para las estrellas es el siguiente:
</p>
<p>Embed: <code>compute-star.java</code></p>
<p>
Ahora solo resta construir una interfaz para la aplicación, sin embargo eso esta fuera del alcance de este post así que no entraremos en detalles. Al final les dejo el código completo de la aplicación por si acaso. He aquí el resultado:
</p>
<figure>
<img src="/de-poligonos-y-estrellas/polygon_test.png" alt="El resultado" />
<figcaption aria-hidden="true">El resultado</figcaption>
</figure>
<p>
Hasta aquí con este post, espero les sea de utilidad. He de comentarles que este tema de los gráficos por computadora es uno de mis temas favoritos ya que es aquí donde encuentro una aplicación práctica e interesante a tanta teoría de mis cursos de matemáticas. Tengo planes de hacer una serie de artículos a cerca de estos temas con más detalle y aplicaciones. Hasta la próxima!
</p>
<h2 id="referencias">Referencias</h2>
<ol>
<li>
Computer Graphics for Java Programmers, Second Edition <em>by Leen AmmeraalandKang Zhang</em>
</li>
<li>
<a href="http://es.wikipedia.org/wiki/Coordenadas_polares" target="_blank">Coordenadas polares</a>, <em>Wikipedia</em>
</li>
<li>
<a href="http://es.wikipedia.org/wiki/Coordenadas_cartesianas" target="_blank">Coordenadas cartesianas</a>, <em>Wikipedia</em>
</li>
</ol>

