<h1 id="z-algorithm">Z algorithm</h1>

<p class='metadata'>
    <span class='published'><span class="fa-solid fa-clock"></span> <em>2016-02-18</em></span>
	<span class='updated'><span class="fa-solid fa-clock-rotate-left"></span> <em>2024-05-07</em></span>
    <span class='tags'><span class="fa-solid fa-tag"></span><code>#algorithms</code> <code>#post</code></span>
</p>

<p>String matching is a very common problem, given a text <span class="math inline"><em>T</em></span> and a pattern <span class="math inline"><em>P</em></span> find the occurrences of <span class="math inline"><em>P</em></span> in <span class="math inline"><em>T</em></span>. This problem doesn’t need too much introduction.</p>
<p>The most easy (and naive) algorithm to solve this problem is to slide off <span class="math inline"><em>P</em></span> through <span class="math inline"><em>T</em></span> and see if there is a match. Something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> P<span class="op">.</span>length <span class="op">&lt;=</span> T<span class="op">.</span>length<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>P<span class="op">[</span>j<span class="op">]</span> <span class="op">==</span> T<span class="op">[</span>i<span class="op">+</span>j<span class="op">])</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        j<span class="op">++;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">==</span> P<span class="op">.</span>length<span class="op">)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We found a match!</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>However, much more efficient solutions exists to this problem, the Z algorithm is one of them.</p>
<h2>
The <span class="math inline"><em>Z</em><sub><em>i</em></sub>(<em>T</em>)</span> function
</h2>
<div class="box">
<p>The <span class="math inline"><em>Z</em><sub><em>i</em></sub>(<em>T</em>)</span> is equal to the length of the longest substring starting at position <span class="math inline"><em>i</em> &gt; 0</span> that matches a prefix of <span class="math inline"><em>T</em></span>.</p>
</div>
<p>For example, let be T = “cabacadcab”, <span class="math inline"><em>Z</em><sub>3</sub> = 0</span>, <span class="math inline"><em>Z</em><sub>4</sub> = 2</span> and <span class="math inline"><em>Z</em><sub>7</sub> = 3</span>. Obviously <span class="math inline"><em>Z</em><sub>0</sub></span> is always equal to the length of the string. See figure .</p>
<figure>
<img src="/z-algorithm/z_alg_example.png" alt="Z Algorithm example" />
<figcaption aria-hidden="true">Z Algorithm example</figcaption>
</figure>
<h2 id="z-boxes">Z Boxes</h2>
<div class="box">
<pre><code>If $Z_{i} &gt; 0$ a Z-box is a substring that starts at position $i$ and ends at position $i + Z_{i} - 1$, i.e. the substring that matches the prefix of $T$.</code></pre>
</div>
<figure>
<img src="/z-algorithm/z_boxes.svg" alt="Z-Boxes" />
<figcaption aria-hidden="true">Z-Boxes</figcaption>
</figure>
<p>Assume that we have already computed the values of <span class="math inline"><em>Z</em></span> upto some <span class="math inline"><em>k</em> − 1</span> and now we need to compute <span class="math inline"><em>Z</em><sub><em>k</em></sub></span>. There are four possible cases. In the following pictures <span class="math inline"><em>l</em></span> and <span class="math inline"><em>r</em></span> denote de start and the end of the last Z-box.</p>
<h3 id="case-1-k-is-out-of-the-last-z-box">Case 1: $ k $ is out of the last Z-box</h3>
<p>Position <span class="math inline"><em>k</em></span> is not contained in the last Z-box. We need to compare character by character to find <span class="math inline"><em>Z</em><sub><em>k</em></sub></span>.</p>
<figure>
<img src="/z-algorithm/z_alg_cases_1.svg" alt="Case 1" />
<figcaption aria-hidden="true">Case 1</figcaption>
</figure>
<h3 id="case-2-k-is-within-the-last-z-box">Case 2: $ k $ is within the last Z-box</h3>
<p>We’ll denote this last Z-box as <span class="math inline"><em>α</em></span> and as <span class="math inline"><em>β</em></span> the box starting at position <span class="math inline"><em>k</em></span> and ending at <span class="math inline"><em>r</em></span>. Since every Z-box matches a prefix, the following figure depicts our situation.</p>
<figure>
<img src="/z-algorithm/z_alg_cases_2.svg" alt="Case 2" />
<figcaption aria-hidden="true">Case 2</figcaption>
</figure>
<p>As you can see, <span class="math inline"><em>k</em>′</span> corresponds to position <span class="math inline"><em>k</em></span> in the prefix and we already computed <span class="math inline"><em>Z</em><sub><em>k</em>′</sub></span> and so we can leverage this fact. There are three more cases.</p>
<h4 id="case-2a-z_k-beta">Case 2a: $ Z_{k’} &lt; |\beta| $</h4>
<p>In this case <span class="math inline"><em>Z</em><sub><em>k</em></sub> = <em>Z</em><sub><em>k</em>′</sub></span>.</p>
<figure>
<img src="/z-algorithm/z_alg_cases_2a.svg" alt="Case 2a" />
<figcaption aria-hidden="true">Case 2a</figcaption>
</figure>
<h4 id="case-2b-z_k-beta">Case 2b: $ Z_{k’} &gt; |\beta| $</h4>
<p>Let be <span class="math inline"><em>x</em></span> the first character that is not contained in the last Z-box and <span class="math inline"><em>y</em></span> the first character that is not contained in the prefix, we know one thing, <span class="math inline"><em>x</em> ≠ <em>y</em></span> and therefore <span class="math inline"><em>Z</em><sub><em>k</em></sub></span> cannot be greater than <span class="math inline"><em>Z</em><sub><em>k</em>′</sub></span>. Result <span class="math inline"><em>Z</em><sub><em>k</em></sub> = |<em>β</em>|</span>.</p>
<figure>
<img src="/z-algorithm/z_alg_cases_2b.svg" alt="Case 2b" />
<figcaption aria-hidden="true">Case 2b</figcaption>
</figure>
<h4 id="case-2c-z_k">Case 2c: $ Z_{k’} = || $</h4>
<figure>
<img src="/z-algorithm/z_alg_cases_2c.svg" alt="Case 2c" />
<figcaption aria-hidden="true">Case 2c</figcaption>
</figure>
<p>Here we know two things, <span class="math inline"><em>x</em> ≠ <em>y</em></span> and <span class="math inline"><em>y</em> ≠ <em>w</em></span>. How about <span class="math inline"><em>x</em></span> and <span class="math inline"><em>w</em></span>? We don’t know, they may be equal or not. In this case it’s necessary to verify.</p>
<p>Okay, here is an implementation to complement the explanation:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>Z<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> l <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;</span> n<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>r <span class="op">&lt;</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> r <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>S<span class="op">[</span>r<span class="op">]</span> <span class="op">==</span> S<span class="op">[</span>r<span class="op">-</span>l<span class="op">])</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            r<span class="op">++;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        Z<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> r <span class="op">-</span> l<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> b <span class="op">=</span> r <span class="op">-</span> k<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> j <span class="op">=</span> k <span class="op">-</span> l<span class="op">;</span> <span class="co">// j is k&#39;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>Z<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            Z<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> Z<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>Z<span class="op">[</span>j<span class="op">]</span> <span class="op">&gt;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            Z<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> k <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(</span>S<span class="op">[</span>r<span class="op">]</span> <span class="op">==</span> S<span class="op">[</span>r<span class="op">-</span>l<span class="op">])</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                r<span class="op">++;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            Z<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> r <span class="op">-</span> l<span class="op">;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Since <span class="math inline"><em>l</em></span> and <span class="math inline"><em>r</em></span> never decrease the complexity of this algorithm is <span class="math inline"><em>O</em>(<em>n</em>)</span>.</p>
<h2 id="string-matching-using-the-z-function">String matching using the Z function</h2>
<p>Now that we know how to compute the Z function let’s see how to use it to find the occurrences of a pattern <span class="math inline"><em>P</em></span> in a text <span class="math inline"><em>T</em></span>. The idea is easy:</p>
<ol>
<li>
Concatenate <span class="math inline"><em>P</em></span> with <span class="math inline"><em>T</em></span> and compute the Z function in the resulting string (<span class="math inline"><em>S</em></span> = <span class="math inline"><em>P</em></span> + <span class="math inline"><em>T</em></span> )
</li>
<li>
There is an occurrence of <span class="math inline"><em>P</em></span> that start at position <span class="math inline"><em>i</em> &gt;  = |<em>P</em>|</span> if <span class="math inline"><em>Z</em><sub><em>i</em></sub>(<em>S</em>) &gt;  = |<em>P</em>|</span>.
</li>
</ol>
<h2>
Practice problems
</h2>
<p>Here are some problems to put into practice this algorithm:</p>
<ul>
<li>
<a href="http://codeforces.com/contest/432/problem/D">Codeforces Round #246 Div 2 Problem D: Prefixes and Suffixes</a> | <a href="https://gist.github.com/rendon/0cd66d5891b5758cd382">My solution</a>
</li>
<li>
<a href="http://lightoj.com/volume_showproblem.php?problem=1255">Light OJ: 1255 - Substring Frequency</a> | <a href="https://gist.github.com/rendon/43bbc8f3fbcb8d231c99">My solution</a>
</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.cs.ucdavis.edu/~gusfield/cs122f10/videolist.html">Linear-time pattern matching. Z-values and Z-algorithm</a></li>
</ul>

